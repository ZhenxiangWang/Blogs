# 单一职责原则

### 单一职责原则是什么？

一个组件只能拥有一个职责，只能有一个变化的原因。通俗点理解就是，一个组件只做一件事，也只因为这件事的变化而改变。其他事情的变化影响不到这个组件。

### 单一职责的粒度

* 渲染一个列表
* 显示一个时间选择器
* 发起一次 HTTP 请求
* 描绘一幅图表
* 懒加载一个图片
* ...

### 遵守单一职责原则的好处

* 架构清晰，有助于阅读和维护。组件易测试。
* 有利于组件重用。
* 让业务分工明确，开发人员仅专注于自己的业务。
* 每个组件负责独立的功能，与其他组件解耦合。不同组件的修改互相被隔离开，变得可控。
* 减少不必要渲染。

### 不遵守单一职责原则的坏处

* 代码量大，难以阅读，维护和测试。
* 组件难以被重用。
* 业务分工不明确，开发人员需要考虑对其他业务的影响。
* 因为一个原因去修改组件时，很可能会误伤这个组件的其他职责，产生无法预期的破坏。
* 任何一个操作都可能导致整个应用重新渲染。

### 根据单一职责原则拆分组件

#### 一、展示组件和容器组件

**展示组件**

* 职责：关注页面的展示效果（外观）
* 内部可以包含展示组件和容器组件，通常会包含一些自己的 DOM 标记和样式\(style\)
* 对应用程序的其他部分没有依赖关系，例如 actions 或 store。
* 不用关心数据是怎么加载和变动的。
* 只能通过 props 的方式接收数据和进行回调\(callback\)操作。
* 很少拥有自己的状态，即使有也是用于展示 UI 状态的。
* 会被写成函数式组件除非该组件需要自己的状态，生命周期或者做一些性能优化。
* 例子：Page, Sidebar, Story, UserInfo, List.

**容器组件：**

* 职责：关注业务逻辑，功能实现。
* 内部可以包含容器组件和展示组件，但通常没有任何自己的 DOM 标记，除了一些包装 divs，并且从不具有任何样式。
* 提供数据和方法给其他的展示组件或容器组件。
* 往往是有状态的，因为它们倾向于作为数据源
* 通常使用高阶组件生成，例如 React Redux 的 connect（），而不是手工编写。
* 例子: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.

**展示组件和容器组件分离的好处**

* 展示和容器组件更好的分离，有助于更好的理解应用和 UI
* 重用性高，展示组件可以用于多个不同数据源。
* 可以把展示组件放到单独的页面，在不影响应用程序的情况下，让设计师调整 UI。
* 这迫使你提取诸如侧边栏，页面，上下文菜单等“布局组件”并使用 this.props.children，而不是在多个容器组件中复制相同的标记和布局。

#### 二、高阶组件

